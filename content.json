[{"title":"SpringCloud Config分布式配置中心","date":"2019-11-20T10:19:36.000Z","path":"2019/11/20/SpringCloud Config分布式配置中心/","text":"SpringCloud Config为微服务架构中的微服务提供了集中化的外部配置支持，配置服务器为各自不同微服务应用的所有环境提供了一个中心化的外部配置。服务端： 称为分布式配置中心，是一个独立的微服务应用，用来连接配置服务器并为客户端提供配置信息，加密/解密信息等访问接口。客户端： 通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。 config服务端使用需要向集群注册自己，config的客户端才能访问pom加入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; yml加入 server: port: 3344 spring: application: name: microservicecloud-config cloud: config: server: git: uri: https://github.com/a984958991/microservicecloud-config #GitHub上面的git仓库名字 主启动类 @SpringBootApplication @EnableConfigServer public class Config_3344_StartSpringCloudApp { public static void main(String[] args) { SpringApplication.run(Config_3344_StartSpringCloudApp.class, args); } } 测试访问方式：http://localhost:3344/application-dev.yml config客户端使用pom加入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; 加入优先级最高的bootstrap.yml（系统级） spring: cloud: config: name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名 profile: test #本次访问的配置项 label: master uri: http://config-3344.com:3344 #本微服务启动后先去找3344号服务，通过SpringCloudConfig获取GitHub的服务地址 config服务端的地址 示例配置文件码云地址: https://gitee.com/jinqiansheng/microservicecloud-config","tags":[{"name":"微服务","slug":"微服务","permalink":"https://jinqiansheng.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://jinqiansheng.github.io/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]},{"title":"Zuul路由网关","date":"2019-11-19T10:19:36.000Z","path":"2019/11/19/Zuul路由网关/","text":"提供代理、路由、过滤三大功能。路由：负责将外部请求转发的具体的微服务实例上，是实现外部统一访问入口的基础。过滤：对请求的处理过程进行干预，实现校验、服务聚合等功能。它将自身注册为Eureka服务治理下的应用，同时从Eureka中获取其他微服务的消息。 使用pom加入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; yml加入 zuul: #ignored-services: microservicecloud-dept #原真实服务名忽略(指定服务名\",\"分隔) prefix: /jqs #统一的公共前缀 ignored-services: \"*\" #忽略所有的真实服务名忽略 routes: mydept.serviceId: microservicecloud-dept #服务的实例名 mydept.path: /mydept/** #映射后的访问名 主启动类 @SpringBootApplication @EnableZuulProxy public class Zuul_9527_StartSpringCloudApp { public static void main(String[] args) { SpringApplication.run(Zuul_9527_StartSpringCloudApp.class, args); } }","tags":[{"name":"微服务","slug":"微服务","permalink":"https://jinqiansheng.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://jinqiansheng.github.io/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]},{"title":"Hystrix断路器","date":"2019-11-18T10:19:36.000Z","path":"2019/11/18/Hystrix断路器/","text":"用于服务熔断和服务降级，能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个符合预期的，可处理的备选响应，而不是长时间的等待或抛出异常。 服务熔断pom加入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 主启动类 @SpringBootApplication @EnableEurekaClient//本服务启动后会自动注册进eureka服务中 @EnableDiscoveryClient//服务发现 @EnableCircuitBreaker//对hystrixR熔断机制的支持 public class DeptProvider8001_Hystrix_App { public static void main(String[] args) { SpringApplication.run(DeptProvider8001_Hystrix_App.class, args); } } 调用 @GetMapping(\"getByid/{id}\") @HystrixCommand(fallbackMethod = \"processHystrix_Get\") //出现异常执行执行\"processHystrix_Get\"方法 public Dept get(@PathVariable(\"id\") Integer id) { Optional&lt;Dept&gt; op = deptList.stream().filter(e -&gt; e.getDeptno() == id).findFirst(); if(op.isPresent()) { return op.get(); }else { throw new RuntimeException(\"该ID：\" + id + \"没有没有对应的信息\"); } } public Dept processHystrix_Get(@PathVariable(\"id\") Integer id) { return new Dept().setDeptno(id).setDname(\"该ID：\" + id + \"没有没有对应的信息,null--@HystrixCommand\") .setDbSource(\"没得信息哇\"); } 以上处理方式属于简易型的服务熔断。实际项目中熔断和降级是共同处理，我的理解就是使用通过熔断的机制达到服务降级的目的。 服务降级服务的降级处理是在客户端完成，服务端不做处理yml加入 feign: hystrix: enabled: true 在@FeignClinent注解中加上fallbackFactory属性值 @FeignClient(value = \"MICROSERVICECLOUD-DEPT\",fallbackFactory=DeptClientServiceFallbackFactory.class) @RequestMapping(\"/dept\") public interface DeptClientService { @GetMapping(\"/list\") public List&lt;Dept&gt; list(); @GetMapping(\"getByid/{id}\") public Dept get(@PathVariable(\"id\") Integer id); } 实现fallbackFactory属性值中的类 @Component//必须加否则无效果 //实现FallbackFactory&lt;T&gt; 接口 T为service public class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService&gt;{ @Override public DeptClientService create(Throwable cause) { return new DeptClientService() { @Override public List&lt;Dept&gt; list() { return null; } @Override public Dept get(Integer id) { return new Dept().setDeptno(id).setDname(\"该ID：\" + id + \"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭\"); } }; } } hystrixDashboard服务监控Hystrix会通过hystrix-mettics-event-stream项目持续记录所有通过Hystrix发起的请求执行信息，并以报表的形式展示。POM加入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; 主启动类 @SpringBootApplication @EnableHystrixDashboard public class DeptConsumer_DashBoard_App { public static void main(String[] args) { SpringApplication.run(DeptConsumer_DashBoard_App.class, args); } } 被监控的服务提供者pom需要加入actuator &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 输入hystrixDashboard微服务的地址查看如：http://localhost:9001/hystrix 查看图形化界面，再根据提示查看特定微服务的访问图形化统计 实心圆： 通过颜色变化代表健康程度，分别从绿色&lt;黄色&lt;橙色&lt;红色递减。同时流量越大实心圆越大曲线： 可以记录指定毫秒内流量的上升和下降趋势","tags":[{"name":"微服务","slug":"微服务","permalink":"https://jinqiansheng.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://jinqiansheng.github.io/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]},{"title":"Feign负载均衡","date":"2019-11-17T10:19:36.000Z","path":"2019/11/17/Feign负载均衡/","text":"Feign是一个声明式的WebService客户端，使用Feign能让编写Web Service客户端更加简单。支持JAx-RS标准的注解，支持可拔插式的编码器和解码器，支持Spring MVC标准注解和HttpMessageConverters。可以与Eureka和Ribbon组合使用支持负载均衡。简单来说就是Feign封装Ribbon，在实际使用一个借口会被多个消费方调用，使用Feign可以封装这些服务提供方的接口，只需要加上一个Feign注解即可，简化了使用ribbon时自动封装服务调用客户端的开发量 消费方客户端使用&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; 主启动类示例 @SpringBootApplication(scanBasePackages = \"com.jqs.springcloud\")//启动时扫描哪些包 @EnableFeignClients(basePackages= {\"com.jqs.springcloud\"})//扫描所有使用注解@FeignClient定义的feign客户端 public class DeptConsumerFeign_App { public static void main(String[] args) { SpringApplication.run(DeptConsumerFeign_App .class, args); } } 接口实现接口实现服务提供者开放的接口 @FeignClient(value = \"MICROSERVICECLOUD-DEPT\") @RequestMapping(\"/dept\") public interface DeptClientService { @GetMapping(\"/list\") public List&lt;Dept&gt; list(); } 调用 调用时只需要调用@FeignClient注解的借口即可调用服务提供者的api，且默认的轮询负载均衡，如果有需要可以重写负载均衡算法。 @Autowired private DeptClientService deptClientService; 如果报错误异常，提示找不到@FeignClient注解的vlaue的属性赋值的实例名，则需要在yml配置实例名所指向的实际服务地址(具体我也没找到原因，在debug的源码，发现@Autowired 带有@FeignClient的接口信息时 allServiceList为null。以后在研究)，如 MICROSERVICECLOUD-DEPT: ##实例名 ribbon: ## 服务提供者的地址，不是服务注册中心的地址 listOfServers: http://localhost:8001,http://localhost:8002,http://localhost:8003 ## 这个要有，如果不加，只加了上面也没用 ribbon: eureka: enabled: false","tags":[{"name":"微服务","slug":"微服务","permalink":"https://jinqiansheng.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://jinqiansheng.github.io/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]},{"title":"Ribbon负载均衡","date":"2019-11-16T10:19:36.000Z","path":"2019/11/16/Ribbon负载均衡/","text":"Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡工具。 主要提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起，提供一系列完善的配置项，如连接超时、重试等。简单来说就是在配置文件中列出Load Balancer(简称LB)后面所有的极其，Ribbon自动帮你基于某种规则去连接，并可以自定义负载均衡算法。 使用Ribbon是一套客户端的负载均衡工具，需要在消费方使用pom引入相关jar包 &lt;!-- Ribbon相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; yml加入 eureka: client: register-with-eureka: false #不注册自身 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ #eureka集群 主启动类 @SpringBootApplication @EnableEurekaClient public class Consumer_App { public static void main(String[] args) { SpringApplication.run(Consumer_App.class, args); } } 在ConfigBean声明的BeanRestTemplate需要加入@LoadBalanced注解，restTemplate就可以通过微服务名进行访问,默认采用轮询的负载均衡算法 @Configuration public class ConfigBean { @Bean @LoadBalanced public RestTemplate getRestTemplate() { return new RestTemplate(); } /** *定义负载均衡算法，不写默认为轮询 **/ @Bean public IRule myRule() { return new RandomRule(); } } Ribbon核心组件IRule默认的7种负载均衡的算法 名称 说明 RoundRobinRule 轮询算法（是Ribbon默认的负载均衡机制） RandomRule 随机访问算法 RetryRule 先按照 RoundRobinRule 的策略访问服务，如果访问的服务宕机或者出现异常的情况，则在指定时间内会进行重试，访问其它可用的服务 BestAvailableRule 首先会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务访问 ZoneAvoidanceRule 默认规则,复合判断server所在区域的性能和server的可用性选择服务器 AvailabilityFilteringRule 首先会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问 WeightedResponseTimeRule 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高。刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够，会切换到WeightedResponseTimeRule Ribbon自定义负载均衡算法使用自定义Ribbon 需要再主启动类上加入@RibbonClient注意：自定义的负载均衡算法配置类不能放在@ComponentScan所扫描的当前包下以及包下，否则自定义的这个配置类就会被所有的Ribbon客户端共享。 主启动加入@RibbonClient注解 @SpringBootApplication @EnableEurekaClient //在启动该微服务的时候就能去加载我们的自定义Ribbon配置类，从而使配置生效 //name = 微服务名 //configuration = 自定义负载均衡算法的类 @RibbonClient(name=\"MICROSERVICECLOUD-DEPT\",configuration=MySelfRule.class) public class Consumer_App { public static void main(String[] args) { SpringApplication.run(Consumer_App.class, args); } } 自定义写法与调用Ribbon自带的7种类似，但需要自己写类去实现AbstractLoadBalancerRule接口，具体写法可参照自带的7种负载均衡算法去实现（比如参照轮询或者随机这种比较简单的负载均衡算法的源码去实现自己想要的）。 @Configuration public class MySelfRule { @Bean public IRule myRule() { return new RoundRobinRule_T();//自定义负载均衡 } }","tags":[{"name":"微服务","slug":"微服务","permalink":"https://jinqiansheng.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://jinqiansheng.github.io/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]},{"title":"Eureka服务注册于发现","date":"2019-11-15T10:19:36.000Z","path":"2019/11/15/Eureka服务注册于发现/","text":"Eureka用于实现服务注册和发现，是Netflix的一个子模块，也是核心模块之一。Eureka是一个极具Rest的服务，用于定位服务，以实现云端中间层服务发现和故障转移。服务注册于发现对于微服务架构来说是非常重要的，有了服务发现与注册，只需要使用服务器的标识符，就可以访问到服务，而不需要修改服务调用的配置文件。功能类似于dubbo的注册中心，比如Zookeeper。Eureka采用了C-S的设计架构，Eureka Server 作为服务注册功能的服务器，是服务的注册中心，而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。SpringCloud的一些其他的模块(比如Zuul)就可以通过Eureka Server来发现系统中的其他微服务，并执行相关逻辑。简单来说就是负责发现和注册微服务，并通过Eureka Server维持各个微服务之间的心跳连接。 两大组件：Eureka Server：提供注册服务,各个节点启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所以可用服务节点的信息，服务节点的信息可以在界面中直观的看到。 Eureka Client： 是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置、使用轮询负载算法的负载均衡器。再应用启动后，将会向Eureka Server发送心跳（默认周期是30秒）。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒） Eureka对比Zookeeper的优点：在CAP的理论中,一个分布式系统不能同时满足C（一致性）、A（可用性）、P（分区容错性）。由于分区容错性P在分布式系统中必须要保证，因此只能在A和C之间进行权衡。 CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性） 分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。 CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足 。因此在进行分布式架构设计时，必须做出取舍。当前一般是通过分布式缓存中各节点的最终一致性来提高系统的性能，通过使用多节点之间的数据异步复制技术来实现集群化的数据一致性。通常使用类似 memcached 之类的 NOSQL 作为实现手段。虽然 memcached 也可以是分布式集群环境的，但是对于一份数据来说，它总是存储在某一台 memcached 服务器上。如果发生网络故障或是服务器死机，则存储在这台服务器上的所有数据都将不可访问。由于数据是存储在内存中的，重启服务器，将导致数据全部丢失。当然也可以自己实现一套机制，用来在分布式 memcached 之间进行数据的同步和持久化，但是实现难度是非常大的 。 Zookeeper保证的是CP服务注册功能对一致性要求高，当master节点因为网络故障和其他节点失去联系时，剩余节点会重新进行Leader选举。这个时间持续30~120s，选举期间整个zk集群为不可用的，导致选举期间服务注册瘫痪。Eureka则是AP优先保证可用性，Eureka各个节点都是平等的，如果某几个几点故障，只要有一台Eureka在，就能保证注册服务可用，只不过查到的信息可能不是最新的，而Eureka的自我保护机制，如果在15分钟内超过85的节点都没有正常心跳，那么Eureka就认为客户端与注册中心出现网络故障，会出现以下几种情况 Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务 Eureka仍然能够接受新的服务注册和查询请求，但不会同步到其他节点，只保证当前节点依然可用 当网络稳定时，当前实例新注册的信息会同步到其他节点 Eureka可以很好的应对网络故障导致的部分节点失去联系的情况，而不会像Zookeeper那样使整个注册服务瘫痪。 EurekaServer使用pom引入jar包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; yml加入 eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 启动类加入注解启用 @SpringBootApplication @EnableEurekaServer public class EurekaServer_App { public static void main(String[] args) { SpringApplication.run(EurekaServer_App.class, args); } } EurekaClient 使用pom引入jar包 &lt;!-- 将微服务provider侧注册进eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; yml加入 eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka #EurekaServer的地址 instance: instance-id: microservicecloud-dept8001 #别名 prefer-ip-address: true #访问路径可以显示IP地址 启动类加入注解注册 @SpringBootApplication @EnableEurekaClient public class EurekaClient_App { public static void main(String[] args) { SpringApplication.run(EurekaClient_App .class, args); } } 服务提供者加入info监控信息父maven项目加入 &lt;build&gt; &lt;finalName&gt;microservicecloud&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;delimit&gt;$&lt;/delimit&gt; &lt;/delimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; pom加入 &lt;!-- actuator监控信息完善 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; yml加入 info: #点击别名页面所显示的说明 app.name: atguigu-microservicecloud company.name: www.atguigu.com build.artifactId: $project.artifactId$ build.version: $project.version$ Eureka自我保护机制某时刻某一微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存。默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例，（默认90秒），但是当网络分区故障发生时，微服务与EurekaServer之间无法正常通信，Eureka会通过自我保护机制解决这个问题，一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务祖册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该EurekaServer节点会自动退出自我保护模式。自我保护模式中，EureKa Server会保护服务注册表中的信息，不再注销任何服务实例。当它收到心跳数重新恢复到阀值以上时，该EurekaServer 节点会自动退出自我保护模式。 总的来说就是在触发EurekaServer的保护模式后，它宁可保留错误的服务注册信息，也不会盲目注销任何可能健康的服务实例。 禁用自我保护模式Eureka Server端 eureka.server.enable-self-preservation #设为false，关闭自我保护 eureka.server.eviction-interval-timer-in-ms #清理间隔（单位毫秒，默认是60*1000） Eureka Client端 eureka.client.healthcheck.enabled #开启健康检查（需要spring-boot-starter-actuator依赖） eureka.instance.lease-renewal-interval-in-seconds #续约更新时间间隔（默认30秒） eureka.instance.lease-expiration-duration-in-seconds #续约到期时间（默认90秒 Discovery服务发现用于发现服务提供者主启动类上引用 @SpringBootApplication @EnableDiscoveryClient //服务发现 public class EurekaClient_App { public static void main(String[] args) { SpringApplication.run(EurekaClient_App.class, args); } } 调用代码使用示例 @Autowired private DiscoveryClient client; public Object discovery() { List&lt;String&gt; list = client.getServices(); System.out.println(\"**********\" + list); List&lt;ServiceInstance&gt; srvList = client.getInstances(\"MICROSERVICECLOUD-DEPT\"); for (ServiceInstance element : srvList) { System.out.println(element.getServiceId() + \"\\t\" + element.getHost() + \"\\t\" + element.getPort() + \"\\t\" + element.getUri()); } return this.client; } 集群配置多个EurekaServer可以互相牵手形成集群，某一个注册中心因为特殊原因发生故障服务提供者无法注册时会向集群中的别的EurekaServer注册，当故障解除后集群中的EurekaServer再进行同步注册信息。在EurekaServer yml中配置牵手 eureka.client.service-url.defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ 在Eureka client中向集群的所有EurekaServer注册 yml配置如下 eureka.client.service-url.defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/","tags":[{"name":"微服务","slug":"微服务","permalink":"https://jinqiansheng.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://jinqiansheng.github.io/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]},{"title":"SpringCloud概述","date":"2019-11-14T10:19:36.000Z","path":"2019/11/14/SpringCloud概述/","text":"分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的几何体，俗称微服务全家桶。 SpringCloud和SrpingBoot的关系 SpringBoot专注于快速方便开发单个个体微服务 SpringCloud是关注全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供配置管理、服务发现、断路器、路由、微代理、实践总线、全局锁、决策竞选、分布式会话等等集成服务 SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系 Dubbo和SpringCloud的区别：技术栈对比 技术栈 Dubbo SpringCloud 服务注册中心 Zookeeper(第三方) Srping Cloud Netflix Eureka 服务调用方式 RPC Rest API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netflix Hystrix 服务网关 无 Spring Cloud Netflix Zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task …… 区别： SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的Rest方式，严格来说，这两种方式各有优劣。虽然一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且Rest相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速烟花的微服务环境下，显得更加灵活。 SpringCloud提供了分布式的一站式服务对自身各个组件有大量的兼容测试，而Dubbo构建的微服务架构，自由度很高，但是需要开发人员对各组件的基础有足够的了解，从构建项目的成本来讲SpringCloud要优于Dubbo。 社区支持和更新力度，Dubbo停止更新了5年左右，SpringCloud是Spring的拳头项目，更新力度较高，社区也相对活跃，学习成本低于Dubbo。 HTTP： 是指从客户端到服务端的请求消息，请求是使用具有标准定义的通用接口定向到资源的，这些语义能够被中间件和提供服务的来源机器进行解释。这样会使一个应用支撑分层的转换和间接层，并且独立于消息的来源，这对于一个Internet规模，多个组织，无法控制的可伸缩的信息系统来说，是非常有用的。主要用于对外的异构环境，浏览器接口调用，app接口调用，第三方接口调用等 PRC： 是远程过程调用协议，根据语言的API来定义的，而不是根据基于网络的应用来定义的。主要用于公司内 &emsp;&emsp;&emsp;&emsp; HTTP RPC 传输协议 基于HTTP协议 可以基于TCP协议，也可以基于HTTP协议； 传输效率 如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0的协议，那么简单的封装一下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理。 使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率。 性能消耗 大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能 可以基于thrift实现高效的二进制传输 负载均衡 需要配置Nginx，HAProxy来实现 基本都自带负载均衡策略 服务治理 需要事先通知，修改Nginx，HAProxy配置 能做到自动通知，不影响上游 开发参考：中文API：https://www.springcloud.cc/spring-cloud-dalston.html中文社区：https://www.springcloud.cn中文网：https://www.springcloud.cc","tags":[{"name":"微服务","slug":"微服务","permalink":"https://jinqiansheng.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://jinqiansheng.github.io/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]},{"title":"微服务概述","date":"2019-11-13T08:19:36.000Z","path":"2019/11/13/微服务概述/","text":"微服务是指开发一个单个小型的但有业务功能的服务，每个服务都有自己的处理和轻量通讯机制，可以部署在单个或多个服务器上。微服务也指一种种松耦合的、有一定的有界上下文的面向服务架构。 特点： 将单个的应用程序作为一套小型服务器开发的方法 每个应用程序都运行在自己的进程中 运用轻量级的机制进行通信（通常是HTTP资源API） 微服务和微服务架构的区别微服务：（强调的是一个一个的个体），它关注的是某一个点，是具体解决某一问题/提供落地对应服务的一个服务应用。 微服务架构:是一种架构模式，提倡将单一的应用程序划分成一组小的服务，相互协调、相互配合。 微服务架构优缺点：优点： 每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求。 开发简单、开发效率提高，每个服务可能只专一的干一件事。 微服务能够被小团队单独开发，团队中的每个人主需要关注自己的工作成果，无需合作才能体现价值 微服务是松耦合的，是功能意义上的服务，开发、部署阶段都是独立的 可以使用不同的语言开发 易与和第三方集成 微服务只是业务逻辑的代码，不会和HTML，CSS或其他界面组件混合。 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库 缺点： 开发人员要处理分布式系统的复杂性 多服务运维难度随服务的增加而增加 系统部署依赖 服务之间的通信成本 数据一致性 系统集成测试 微服务架构技术栈 微服务条目 落地技术 服务开发 SpringBoot、Spring、SpringMVC 服务配置与管理 Netfilx公司的Archaius、阿里的Diamond等 服务注册与发现 Eureka、Consul、Zookeeper等 服务调用 Rest、RPC、gRPC 服务熔断器 Hystrix、Envoy等 负载均衡 Ribbon、Nginx等 服务接口调用 Feign等 消息队列 Kafka、RabbitMQ、ActiveMQ等 服务配置中心管理 SpringCloudConfig、Chef等 服务路由(API网关) Zuul等 服务监控 Zabbix、Nagios、Metrics、Specator等 全链路追踪 Zipkin、Brave、Dapper等 服务部署 Docker、OpenStack、Kubernetes等 数据流操作开发包 SpringCloudStream(封装与Redis、Rabbit、Kafka等发送接收消息) 实践消息总线 SpringCloud Bus …… SrpingCloud作为微服务架构的优势： 微服务架构完整（微服务所需技术栈相对比较完善） 支持Rest支持多种可插拔序列号选择 支持多语言 高可用/容错（服务端Hystrix+客户端Ribbon） 社区活跃度高，文档相对比较丰富","tags":[{"name":"微服务","slug":"微服务","permalink":"https://jinqiansheng.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://jinqiansheng.github.io/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]},{"title":"java8新特性","date":"2019-11-12T08:19:36.000Z","path":"2019/11/12/java8新特性/","text":"Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。这些特性将颠覆以往的写代码习惯，简化开发量。 Lambda表达式示例： 1(parameters) -&gt; expression || (parameters) -&gt;&#123; statements; &#125; 左侧：Lambda 表达式的列表参数，如getValue(T,R); 就应该是(T,R) -&gt; xxxxx，如果无参数就直接写 () -&gt; xxxxx，只有一个参数小括号可以不写; 右侧：Lambda 表达式的方法体（Lambda体），就是对getValue(T,R)的实现，方法体有多条语句 可以用大括号括起来，如：-&gt; {xxxxx;xxxxx;}，只有一条语句 return 和 {}都可以不写; 注意：Lambda表达式只支持函数式接口（只有一个方法的接口）可以使用@FunctionalInterface 修饰，可以检查接口是否是函数式接口; 四大内置核心函数： 类名 类型 方法 Consumer&lt; T &gt; 消费型接口 void accept(T t) Supplier&lt; T &gt; 供给型接口 T get() Function&lt; T, R &gt; 函数型接口 R apply(T t) Predicate&lt; T &gt; 断言型接口 boolean test(T t) 其他函数式接口： 类名 参数说明 方法 BiFunction&lt;T, U, R&gt; 参数类型有2个，为T、U，返回值为 R R apply(T t, U u); UnaryOperator&lt; T &gt; 参数为T，对参数为T的对象进行一元操作，并返回T类型结果 T apply(T t); BinaryOperator&lt; T &gt; 参数为T，对参数为T得对象进行二元操作，并返回T类型得结果 T apply(T t1， T t2); BiConsumcr(T, U) 参数为T、U，无返回值 void accept(T t, U u); ToIntFunction&lt; T &gt; 参数类型为T，返回值分别为int分别计算int得函数 int applyAsInt(T value); ToLongFunction&lt; T &gt; 参数类型为T，返回值分别为long分别计算long得函数 long applyAsLong(T value); ToDoubleFunction&lt; T &gt; 参数类型为T，返回值分别为double分别计算double得函数 double applyAsDouble(T value); IntFunction&lt; R &gt; 参数分别为int返回值为R R apply(int value); LongFunction&lt; R &gt; 参数分别为long返回值为R R apply(long value) DoubleFunction&lt; R &gt; 参数分别为double返回值为R R apply(double value) 方法引用：若Lambda体中的内容有方法已经实现了，我们可以使用方法引用（可以理解为方法引用是Lambda表达式的另外一种表现形式； 主要有三种语法方式： 123对象::跟实例方法名类::静态方法名类::实例方法名 详解：Lambda体中调用的方法的参数列表与返回值类型必须与函数式接口的抽象方法的参数列表和返回值类型保持一致;若Lambda参数列表中的第一参数是实例方法的调用者，而第二个参数的实例方法的参数时，可以使用ClassName::method; 构造器引用：&nbsp;&nbsp;ClassName::New; 注意：&nbsp;需要调用的构造器的参数列表与函数式接口中的抽象方法的参数列表保持一致;2. 数组引用: &nbsp;&nbsp;Type::new; StreamStream的操作是操作的复制的数据流，不改变原数据; 三个操作步骤: 1. 创建Stream 可以通过Collection系列集合提供的stream()或parallelStream(); 通过Arrays中的静态方法stream()获取数组流; 通过Stream类中的静态方法of(); 通过Stream中的iterate()或generate()使用迭代的方式创建无限流; 2. 中间操作多个中间操作可以连接形成一个流水线，除非流水线触发终止操作，否则中间操作不会执行 任何处理！而是再终止操作时一次性全部处理掉，称为“惰性求值”; 筛选与切片： filter: 接收Lambda,从流中排除某些元素; limit: 阶段流，使其元素不超过给定数量; skip(n)：跳过元素，返回一个扔掉前面n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n)互补; distinct: 筛选，通过流所生成元素的hashCode()和equals()去除重复元素; 映射： map: 接收Lambda，将元素转换成其他形式或提取信息，接收一个函数作为参数，该参数会被应用到每个元素上，并将其映射成一个新元素; flatMap: 接收一个函数作为参数，将流中的每一个值都换成另一个流，然后把所有的流连接成一个流; 排序： sorted() 自然排序 按照Comparable中的compareTo 方法进行排序 sorted(Comparator com) 定制排序 3. 终止操作（终端操作）查找与匹配： allMatch 检查是否匹配所有元素 anyMatch 检查是否至少匹配一个元素 noneMatch 检查是否没有匹配所有元素 findFirst 返回第一个元素 findAny 返回当前流中的任意元素 count 返回流中的元素总个数 max 返回流中的最大值 min 返回流中的最小值 注意：使用stream获取流进行查找默认采用串行，parallelStream是并行查找,可以声明性的通过paraller()与sequential()进行切换并行流和顺序流; Optional类Optional(java.util.Optional) 是一个容器类，代表一个值存在或者不存在，原来null表示一个值不存在，现在Optional可以更好的表达这个概念，并且可以避免空指针异常; 常用方法： Optional.of(T t) 创建一个Optional实例; Optional.empty() 创建一个空的Optional; Optional.ofNullable(T t) 若t不为null，创建Optional实例,否则创建一个空实例; ifPresent() 判断是否包含值; orElse(T t) 如果调用对象包含值，返回该值，否则返回t; orElseGet(Supplier s) 如果调用对象包含值返回该值，否则返回s获取的值; map(Function f) 如果有值对齐处理，并返回处理后的Optional，否则返回Optional.empty(); flatMap(Function mapper) 与map类似，要求返回的值必须是Optional; 新的时间日期APILocalDate 日期、LocalTime 时间、LocalDateTime 日期和时间 是属于不可变的对象，使用的是国际化的ISO-8601日历系统可以通过.now()方法获取当前时间或用of(年，月，日，时，分，秒)获取参数给定的时间; Instant: 时间戳 now()获取默认是UTC时区; Duration: 计算两个时间之间的间隔、period：计算两个日期之间的间隔 TemporalAdjuster: 时间校正器。如将日期调整到下周等操作。TemporalAdjusters 类提供了大量的TemporalAdjuster的实现; DateTimeFormatter: 该类提供了日期格式化的一些常量,也可以使用该类的ofPattern(String)进行自定义; ZonedDate、ZonedTime、ZonedDateTime 带时区的时间，ZoneId类中包含了所有的时区信息，getAvailableZoneIds() 可以获取所有时区信息，of(id) 指定时区信息获取ZoneId对象; 示例： 1LocalDateTime ldt = LocalDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));//获取上海时区的时间;","tags":[{"name":"Java","slug":"Java","permalink":"https://jinqiansheng.github.io/tags/Java/"}]}]