<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>金乾胜</title>
  
  <subtitle>榔头，榔头，有谁看见我的榔头了？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-21T09:06:10.581Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>金乾胜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java8新特性</title>
    <link href="http://yoursite.com/2019/11/21/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/11/21/java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2019-11-21T07:00:36.000Z</published>
    <updated>2019-11-21T09:06:10.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式:"></a>Lambda表达式:</h3><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression || (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><p><strong>左侧：</strong><br>Lambda 表达式的列表参数，如getValue(T,R); 就应该是(T,R) -&gt; xxxxx，如果无参数就直接写 () -&gt; xxxxx，只有一个参数小括号可以不写;</p><p><strong>右侧：</strong><br>Lambda 表达式的方法体（Lambda体），就是对getValue(T,R)的实现，方法体有多条语句 可以用大括号括起来，如：-&gt; {xxxxx;xxxxx;}，只有一条语句 return 和 {}都可以不写;</p><p><strong><font color=#FF0000 >注意：</font></strong><br>Lambda表达式只支持函数式接口（只有一个方法的接口）可以使用@FunctionalInterface 修饰，可以检查接口是否是函数式接口;</p><p><strong>四大内置核心函数：</strong></p><table><thead><tr><th align="center">类名</th><th align="center">类型</th><th align="center">方法</th></tr></thead><tbody><tr><td align="center">Consumer<T></td><td align="center">消费型接口</td><td align="center">void accept(T t)</td></tr><tr><td align="center">Supplier<T></td><td align="center">供给型接口</td><td align="center">T get()</td></tr><tr><td align="center">Function&lt;T, R&gt;</td><td align="center">函数型接口</td><td align="center">R apply(T t)</td></tr><tr><td align="center">Predicate<T></td><td align="center">断言型接口</td><td align="center">boolean test(T t)</td></tr></tbody></table><p><strong>其他函数式接口：</strong></p><table><thead><tr><th align="center">类名</th><th align="left">参数说明</th><th align="center">方法</th></tr></thead><tbody><tr><td align="center">BiFunction&lt;T, U, R&gt;</td><td align="left">参数类型有2个，为T、U，返回值为</td><td align="center">R R apply(T t, U u);</td></tr><tr><td align="center">UnaryOperator<T></td><td align="left">参数为T，对参数为T的对象进行一元操作，并返回T类型结果</td><td align="center">T apply(T t);</td></tr><tr><td align="center">BinaryOperator<T></td><td align="left">参数为T，对参数为T得对象进行二元操作，并返回T类型得结果</td><td align="center">T apply(T t1， T t2);</td></tr><tr><td align="center">BiConsumcr(T, U)</td><td align="left">参数为T、U，无返回值</td><td align="center">void accept(T t, U u);</td></tr><tr><td align="center">ToIntFunction<T></td><td align="left">参数类型为T，返回值分别为int分别计算int得函数</td><td align="center">int applyAsInt(T value);</td></tr><tr><td align="center">ToLongFunction<T></td><td align="left">参数类型为T，返回值分别为long分别计算long得函数</td><td align="center">long applyAsLong(T value);</td></tr><tr><td align="center">ToDoubleFunction<T></td><td align="left">参数类型为T，返回值分别为double分别计算double得函数</td><td align="center">double applyAsDouble(T value);</td></tr><tr><td align="center">IntFunction<R></td><td align="left">参数分别为int返回值为R</td><td align="center">R apply(int value);</td></tr><tr><td align="center">LongFunction<R></td><td align="left">参数分别为long返回值为R</td><td align="center">R apply(long value)</td></tr><tr><td align="center">DoubleFunction<R></td><td align="left">参数分别为double返回值为R</td><td align="center">R apply(double value)</td></tr></tbody></table><p><strong>方法引用：</strong><br>若Lambda体中的内容有方法已经实现了，我们可以使用方法引用（可以理解为方法引用是Lambda表达式的另外一种表现形式；</p><p><strong>主要有三种语法方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象::跟实例方法名</span><br><span class="line">类::静态方法名</span><br><span class="line">类::实例方法名</span><br></pre></td></tr></table></figure><p><strong>详解：</strong><br>Lambda体中调用的方法的参数列表与返回值类型必须与函数式接口的抽象方法的参数列表和返回值类型保持一致;<br>若Lambda参数列表中的第一参数是实例方法的调用者，而第二个参数的实例方法的参数时，可以使用<code>ClassName::method;</code></p><ol><li><strong>构造器引用：</strong>&nbsp;&nbsp;<code>ClassName::New;</code></li></ol><p><strong><font color=#FF0000 >注意：</font></strong>&nbsp;需要调用的构造器的参数列表与函数式接口中的抽象方法的参数列表保持一致;<br>2. <strong>数组引用:</strong> &nbsp;&nbsp;<code>Type::new;</code></p><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream的操作是操作的复制的数据流，不改变原数据;</p><h4 id="三个操作步骤"><a href="#三个操作步骤" class="headerlink" title="三个操作步骤:"></a>三个操作步骤:</h4><p><strong>1. 创建Stream</strong></p><ul><li>可以通过Collection系列集合提供的stream()或parallelStream();</li><li>通过Arrays中的静态方法stream()获取数组流;</li><li>通过Stream类中的静态方法of();</li><li>通过Stream中的iterate()或generate()使用迭代的方式创建无限流; </li></ul><p><strong>2. 中间操作</strong><br>多个中间操作可以连接形成一个流水线，除非流水线触发终止操作，否则中间操作不会执行    任何处理！而是再终止操作时一次性全部处理掉，称为“惰性求值”;   </p><p><strong><font color=#708090>筛选与切片：</font></strong></p><ul><li>filter: 接收Lambda,从流中排除某些元素;</li><li>limit: 阶段流，使其元素不超过给定数量;</li><li>skip(n)：跳过元素，返回一个扔掉前面n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n)互补;</li><li>distinct: 筛选，通过流所生成元素的hashCode()和equals()去除重复元素;  </li></ul><p><strong><font color=#708090>映射：</font></strong></p><ul><li>map: 接收Lambda，将元素转换成其他形式或提取信息，接收一个函数作为参数，该参数会被应用到每个元素上，并将其映射成一个新元素;<ul><li>flatMap: 接收一个函数作为参数，将流中的每一个值都换成另一个流，然后把所有的流连接成一个流;</li></ul></li></ul><p><strong><font color=#708090>排序：</font></strong>   </p><ul><li>sorted() 自然排序 按照Comparable中的compareTo 方法进行排序</li><li>sorted(Comparator com) 定制排序</li></ul><p><strong>3.  终止操作（终端操作）</strong><br>查找与匹配：</p><ul><li>allMatch 检查是否匹配所有元素</li><li>anyMatch 检查是否至少匹配一个元素</li><li>noneMatch 检查是否没有匹配所有元素</li><li>findFirst 返回第一个元素</li><li>findAny 返回当前流中的任意元素</li><li>count 返回流中的元素总个数</li><li>max 返回流中的最大值</li><li>min 返回流中的最小值</li></ul><p><strong><font color=#FF0000 >注意：</font></strong><br>使用stream获取流进行查找默认采用串行，parallelStream是并行查找,可以声明性的通过paraller()与sequential()进行切换并行流和顺序流;</p><h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>Optional(java.util.Optional) 是一个容器类，代表一个值存在或者不存在，原来null表示一个值不存在，现在Optional可以更好的表达这个概念，并且可以避免空指针异常;</p><p><strong>常用方法：</strong></p><ul><li>Optional.of(T t) 创建一个Optional实例;</li><li>Optional.empty() 创建一个空的Optional;</li><li>Optional.ofNullable(T t) 若t不为null，创建Optional实例,否则创建一个空实例;</li><li>ifPresent() 判断是否包含值;</li><li>orElse(T t) 如果调用对象包含值，返回该值，否则返回t;</li><li>orElseGet(Supplier s) 如果调用对象包含值返回该值，否则返回s获取的值;</li><li>map(Function f) 如果有值对齐处理，并返回处理后的Optional，否则返回Optional.empty();</li><li>flatMap(Function mapper) 与map类似，要求返回的值必须是Optional;<h3 id="新的时间日期API"><a href="#新的时间日期API" class="headerlink" title="新的时间日期API"></a>新的时间日期API</h3>LocalDate 日期、LocalTime 时间、LocalDateTime 日期和时间 是属于不可变的对象，使用的是国际化的ISO-8601日历系统可以通过.now()方法获取当前时间或用of(年，月，日，时，分，秒)获取参数给定的时间;</li><li>Instant: 时间戳 now()获取默认是UTC时区;</li><li>Duration: 计算两个时间之间的间隔、period：计算两个日期之间的间隔</li><li>TemporalAdjuster: 时间校正器。如将日期调整到下周等操作。TemporalAdjusters 类提供了大量的TemporalAdjuster的实现;</li><li>DateTimeFormatter: 该类提供了日期格式化的一些常量,也可以使用该类的ofPattern(String)进行自定义;</li><li>ZonedDate、ZonedTime、ZonedDateTime 带时区的时间，ZoneId类中包含了所有的时区信息，getAvailableZoneIds() 可以获取所有时区信息，of(id) 指定时区信息获取ZoneId对象;</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));//获取上海时区的时间;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式:&quot;&gt;&lt;/a&gt;Lambda表达式:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/11/21/hello-world/"/>
    <id>http://yoursite.com/2019/11/21/hello-world/</id>
    <published>2019-11-21T02:03:50.757Z</published>
    <updated>2019-11-21T02:03:50.757Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
